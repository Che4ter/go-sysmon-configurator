package sysmon

import (
	"encoding/xml"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/Che4ter/go-sysmon-configurator/config"
)

func GenerateBaseSysmonConfig(cfg config.Config, buildVersion string) (SysmonConfig, error) {
	var sysmonBaseConfig SysmonConfig
	sysmonBaseConfig.XMLName.Local = "Sysmon"
	sysmonBaseConfig.SchemaversionAttr = cfg.SchemaVersion
	sysmonBaseConfig.ArchiveDirectory = cfg.Defaults.ArchiveDirectory
	sysmonBaseConfig.CheckRevocation = cfg.Defaults.CheckRevocation
	sysmonBaseConfig.CopyOnDeleteExtensions = cfg.Defaults.CopyOnDeleteExtensions
	sysmonBaseConfig.CopyOnDeletePE = cfg.Defaults.CopyOnDeletePE
	sysmonBaseConfig.CopyOnDeleteProcesses = cfg.Defaults.CopyOnDeleteProcesses
	sysmonBaseConfig.CopyOnDeleteSIDs = cfg.Defaults.CopyOnDeleteSIDs
	sysmonBaseConfig.DnsLookup = cfg.Defaults.DNSLookup
	sysmonBaseConfig.DriverName = cfg.Defaults.DriverName
	sysmonBaseConfig.HashAlgorithms = strings.Join(cfg.Defaults.HashAlgorithms, ",")

	sysmonBaseConfig.EventFiltering.RuleGroups = []RuleGroup{}

	sysmonBaseConfig.Comment = " Generated by go-sysmon-configurator genconfig(" + buildVersion + ") at " + time.Now().Format("02.01.2006 15:04:05") + " "

	return sysmonBaseConfig, nil
}

func LoadSysmonModules(basePath string, modulesPath []string) (map[string]EventFiltersContainer, error) {
	eventFiltersMap := make(map[string]EventFiltersContainer)
	for _, modulesPath := range modulesPath {
		xmlFile, err := os.Open(basePath + modulesPath)
		if err != nil {
			return nil, err
		}

		defer xmlFile.Close()

		byteValue, err := ioutil.ReadAll(xmlFile)
		if err != nil {
			return nil, err
		}

		var root struct {
			XMLName xml.Name
		}
		err = xml.Unmarshal(byteValue, &root)
		if err != nil {
			return nil, err
		}

		var ruleGroup RuleGroup
		if root.XMLName.Local == "RuleGroup" {
			err = xml.Unmarshal(byteValue, &ruleGroup)
			if err != nil {
				return nil, err
			}
		} else if root.XMLName.Local == "Sysmon" {
			var sysmonModule SysmonConfig
			err = xml.Unmarshal(byteValue, &sysmonModule)
			if err != nil {
				return nil, err
			}
			ruleGroup = sysmonModule.EventFiltering.RuleGroups[0]
		}

		key := ruleGroup.EventFilters.XMLName.Local
		container := EventFiltersContainer{}

		if _, ok := eventFiltersMap[key]; ok {
			container = eventFiltersMap[key]
		} else {
			container = EventFiltersContainer{
				Includes: EventFilter{XMLName: ruleGroup.EventFilters.XMLName, OnMatchAtt: "include"},
				Excludes: EventFilter{XMLName: ruleGroup.EventFilters.XMLName, OnMatchAtt: "exclude"},
			}
		}

		if ruleGroup.EventFilters.OnMatchAtt == "exclude" {
			container.Excludes.Conditions = append(container.Excludes.Conditions, ruleGroup.EventFilters.Conditions...)
			container.Excludes.Rules = append(container.Excludes.Rules, ruleGroup.EventFilters.Rules...)
			eventFiltersMap[key] = container
		} else if ruleGroup.EventFilters.OnMatchAtt == "include" {
			container.Includes.Conditions = append(container.Includes.Conditions, ruleGroup.EventFilters.Conditions...)
			container.Includes.Rules = append(container.Includes.Rules, ruleGroup.EventFilters.Rules...)
			eventFiltersMap[key] = container
		}
	}
	return eventFiltersMap, nil
}

func AddModulesToConfig(sysmonConfig SysmonConfig, sysmonModules map[string]EventFiltersContainer, cfg []config.EventFilter, generateRuleIds bool, removeRuleNames bool) (SysmonConfig, error) {
	for _, eventType := range cfg {
		if _, ok := sysmonModules[eventType.EventName]; ok {
			if eventType.Include {
				sysmonModules[eventType.EventName].Includes.Sort()
				if generateRuleIds {
					sysmonModules[eventType.EventName].Includes.GenRuleID()
				}
				if removeRuleNames {
					sysmonModules[eventType.EventName].Includes.RemoveRuleNames()
				}

				ruleGroup := RuleGroup{
					EventFilters:      sysmonModules[eventType.EventName].Includes,
					GroupRelationAttr: "or",
				}
				sysmonConfig.EventFiltering.RuleGroups = append(sysmonConfig.EventFiltering.RuleGroups, ruleGroup)
			}

			if eventType.Exclude {
				sysmonModules[eventType.EventName].Excludes.Sort()
				if generateRuleIds {
					sysmonModules[eventType.EventName].Excludes.GenRuleID()
				}
				if removeRuleNames {
					sysmonModules[eventType.EventName].Excludes.RemoveRuleNames()
				}

				ruleGroup := RuleGroup{
					EventFilters:      sysmonModules[eventType.EventName].Excludes,
					GroupRelationAttr: "or",
				}
				sysmonConfig.EventFiltering.RuleGroups = append(sysmonConfig.EventFiltering.RuleGroups, ruleGroup)
			}

		} else {
			if eventType.Include {
				ruleGroup := RuleGroup{
					EventFilters: EventFilter{
						XMLName:    xml.Name{Local: eventType.EventName},
						OnMatchAtt: "include",
						Conditions: []Condition{},
						Rules:      []Rule{},
					},
					GroupRelationAttr: "or",
				}
				sysmonConfig.EventFiltering.RuleGroups = append(sysmonConfig.EventFiltering.RuleGroups, ruleGroup)
			} else if eventType.Exclude {
				ruleGroup := RuleGroup{
					EventFilters: EventFilter{
						XMLName:    xml.Name{Local: eventType.EventName},
						OnMatchAtt: "exclude",
						Conditions: []Condition{},
						Rules:      []Rule{},
					},
					GroupRelationAttr: "or",
				}
				sysmonConfig.EventFiltering.RuleGroups = append(sysmonConfig.EventFiltering.RuleGroups, ruleGroup)
			}
		}
	}

	return sysmonConfig, nil
}

// Removes rule name
func (e EventFilter) RemoveRuleNames() {
	for i := 0; i < len(e.Conditions); i++ {
		e.Conditions[i].NameAttr = ""
	}

	for i := 0; i < len(e.Rules); i++ {
		e.Rules[i].NameAttr = ""
		for j := 0; j < len(e.Rules[i].Conditions); j++ {
			e.Rules[i].Conditions[j].NameAttr = ""
		}
	}
}

// Replaces condition and rule names with id
func (e EventFilter) GenRuleID() {
	id := 1
	prefix := e.XMLName.Local + "_" + e.OnMatchAtt[0:3] + "_"
	for i := 0; i < len(e.Conditions); i++ {
		e.Conditions[i].NameAttr = prefix + strconv.Itoa(id)
		id++
	}

	for i := 0; i < len(e.Rules); i++ {
		e.Rules[i].NameAttr = prefix + strconv.Itoa(id)
		id++
		for j := 0; j < len(e.Rules[i].Conditions); j++ {
			e.Rules[i].Conditions[j].NameAttr = prefix + strconv.Itoa(id)
			id++
		}
	}
}

// DTO to easier work with the individual filters
type EventFiltersContainer struct {
	Includes EventFilter
	Excludes EventFilter
}

// Generic Condition
type Condition struct {
	XMLName       xml.Name
	NameAttr      string `xml:"name,attr,omitempty"`
	ConditionAttr string `xml:"condition,attr"`
	Value         string `xml:",innerxml"`
}

// Subrule
type Rule struct {
	XMLName           xml.Name
	NameAttr          string     `xml:"name,attr,omitempty"`
	GroupRelationAttr string     `xml:"groupRelation,attr"`
	Conditions        Conditions `xml:",any"`
}

// ProcessCreate, FileCreateTime...
type EventFilter struct {
	XMLName    xml.Name
	OnMatchAtt string     `xml:"onmatch,attr"`
	Conditions Conditions `xml:",any"`
	Rules      []Rule     `xml:"Rule,omitempty"`
}

type RuleGroup struct {
	EventFilters      EventFilter `xml:",any"`
	GroupRelationAttr string      `xml:"groupRelation,attr,omitempty"`
}

type EventFilteringRules struct {
	RuleGroups []RuleGroup `xml:"RuleGroup"`
}

// SysmonConfig ...
type SysmonConfig struct {
	XMLName                xml.Name
	Comment                string              `xml:",comment"`
	SchemaversionAttr      string              `xml:"schemaversion,attr"`
	ArchiveDirectory       string              `xml:"ArchiveDirectory,omitempty"`
	CheckRevocation        bool                `xml:"CheckRevocation,omitempty"`
	CopyOnDeleteExtensions string              `xml:"CopyOnDeleteExtensions,omitempty"`
	CopyOnDeletePE         bool                `xml:"CopyOnDeletePE,omitempty"`
	CopyOnDeleteProcesses  string              `xml:"CopyOnDeleteProcesses,omitempty"`
	CopyOnDeleteSIDs       string              `xml:"CopyOnDeleteSIDs,omitempty"`
	DnsLookup              bool                `xml:"DnsLookup,omitempty"`
	DriverName             string              `xml:"DriverName,omitempty"`
	HashAlgorithms         string              `xml:"HashAlgorithms,omitempty"`
	EventFiltering         EventFilteringRules `xml:"EventFiltering"`
}

// Sorting implementation for Condition
// 1. Condition Tag Name, 2. Value
type Conditions []Condition

func (e EventFilter) Sort() {
	sort.Sort(e.Conditions)

	for i := 0; i < len(e.Rules); i++ {
		sort.Sort(e.Rules[i].Conditions)
	}

	sort.Slice(e.Rules, func(i, j int) bool {
		ri, rj := e.Rules[i], e.Rules[j]
		return ri.Conditions[0].Value < rj.Conditions[0].Value

	})
}

func (c Conditions) Less(i, j int) bool {
	ci, cj := c[i], c[j]
	switch {
	case ci.XMLName.Local != cj.XMLName.Local:
		return ci.XMLName.Local < cj.XMLName.Local
	default:
		return ci.Value < cj.Value
	}
}

func (c Conditions) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

func (c Conditions) Len() int {
	return len(c)
}
